### wasn-nn adapter issue
This page describes an issue when trying to create (componse) a new component
model from a core wasm module that uses wasi-nn.

### Issue
So the `.wasm` file is expecting an import interface named `wasi_ephemeral_nn` I
and this would be something that is provided by the runtime, which is why we
were able to run the example using wasmedge.

We can see this import using the following commmand:
```console
$ make print-wat | rustfilt | grep wasi_ephemeral_nn
  (import "wasi_ephemeral_nn" "load_by_name" (func $wasi_nn::generated::wasi_ephemeral_nn::load_by_name (;0;) (type 4)))
        call $wasi_nn::generated::wasi_ephemeral_nn::load_by_name
```
`ephemeral` means short-lived and is one of three stages of the WASI dev process
, the next being `snapshot` and the final being `old` (? is this correct?).

At the time of this writing there is only a single wasi-nn function call which
is the following:
```rust
    let graph =
        wasi_nn::GraphBuilder::new(wasi_nn::GraphEncoding::Ggml, wasi_nn::ExecutionTarget::GPU)
            .build_from_cache(model_name)
            .expect("Failed to build graph from cache");
```
And in our case we can see the syscall to load_by_name which can be found in
https://github.com/second-state/wasmedge-wasi-nn/blob/ggml/rust/src/graph.rs:
```console
    #[inline(always)]                                                           
    pub fn build_from_cache(self, name: &str) -> Result<Graph, Error> where {
        let graph_handle = match self.config.clone() {
            Some(config) => syscall::load_by_name_with_config(name, &config)?,
            None => syscall::load_by_name(name)?,
        };
        Ok(Graph {
            build_info: self,
            graph_handle,
        })
    }
```
So we have `syscall::load_by_name` how and where does this come from?  
Well this is generated by [witx-bindgen] https://github.com/bytecodealliance/wasi/tree/main/crates/witx-bindgen.

The [wasn-nn wit] files are the passed as the input to witx-bindgen which will
[generated] Rust code that we can use to call the wasi-nn functions.

Now, we have other imports, like
```
(import "wasi_snapshot_preview1" "fd_write" (func $wasi::lib_generated::wasi_snapshot_preview1::fd_write (;1;) (type 5)))
```
But we did not get an error for these because we have specified an adapter
for the wasm-tools component new command. If we were to comment out the wasi-nn
code and rebuild the .wasm, plus comment out the `--adapt` options we would get:
```console
error: failed to encode a component from module

Caused by:
    0: module requires an import interface named `wasi_snapshot_preview1`
```
So the adapter is used during the process of transforming a core wasm module to
a component module. It is there to satisfy the imports that don't have WIT
interfaces which is what the component model uses.

So we want to convert from the wasi-nn (wasi-nn.witx) interface to the WIT
interface I think. Basically we need to add an adapter which can be used bytecodealliance
wasm-tools component new command.
